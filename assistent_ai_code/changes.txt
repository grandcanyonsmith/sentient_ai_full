Changes
To create a `list`, try to use `list` comprehension instead of a loop. List comprehension is the preferred way to make a list using Python, and it's simpler and easier to understand than using a loop.

[Learn more](https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions)
Old Code:
def get_stock_resistance_for_any_interval(ticker,current_price,previous_close):
    resistance_levels = ['15','30','60','D','W','M']

    resistance_level_bank = [
        check_if_resistance_broken(
            ticker, level, current_price, previous_close
        )
        for level in resistance_levels
    ]

    return next(
        (
            resistance_level
            for resistance_level in resistance_level_bank
            if resistance_level['break_through'] == 'True'
        ),
        None,
    )

New Code:
def get_stock_resistance_for_any_interval(ticker,current_price,previous_close):
    resistance_level_bank = [
        check_if_resistance_broken(
            ticker, level, current_price, previous_close
        )
        for level in ['15','30','60','D','W','M']
    ]

    return next(
        (
            resistance_level
            for resistance_level in resistance_level_bank
            if resistance_level['break_through'] == 'True'
        ),
        None,
    )



Changes
To check if a container or sequence (string, list, tuple) is empty, use `if not val`. Do not compare its length using `if len(val) == 0` or `if len(val) > 0`

 [Learn more](https://www.python.org/dev/peps/pep-0008/#programming-recommendations#:~:text=if%20not%20seq)
Old Code:
def get_resistance_levels(ticker, interval):
    url = f'https://finnhub.io/api/v1/scan/support-resistance?symbol={str(ticker)}&resolution={str(interval)}&token={finnhub_api_key_2}'

    r = requests.get(url)
    resistance_levels = r.json()
    resistance_levels = resistance_levels['levels']

    if len(resistance_levels) != 0:
        for x in resistance_levels:
            json = {"interval": interval,"resistance":x}
            all_resistances.append(json)
    return resistance_levels
New Code:
def get_resistance_levels(ticker, interval):
    url = f'https://finnhub.io/api/v1/scan/support-resistance?symbol={str(ticker)}&resolution={str(interval)}&token={finnhub_api_key_2}'

    r = requests.get(url)
    resistance_levels = r.json()
    resistance_levels = resistance_levels['levels']

    if resistance_levels:
        for x in resistance_levels:
            json = {"interval": interval,"resistance":x}
            all_resistances.append(json)
    return resistance_levels



Changes
It appears you are unpacking more than three variables while using a function that returns more than one variable. Using a large number of return values is prone to errors. We recommend that you return a small class or `namedtuple` instance instead.

[Learn more](https://docs.python.org/3/library/typing.html#typing.NamedTuple)

Similar issue at line number 146.
Old Code:
def create_resistance_report(ticker,current_price,previous_close):
    get_resistance = get_stock_resistance_for_any_interval(ticker,current_price,previous_close)

    if get_resistance is not None:
        next_highest_resistance, interval = get_next_high_for_any_interval(current_price)
        resistance = float(get_resistance['Resistance']).__round__(2)
        break_through = get_resistance['break_through']
        past_time_interval = get_resistance['time_interval']
        next_time_interval = interval
        price = get_resistance['price']
        next_resistance = float(next_highest_resistance).__round__(2)
        words = f" crossed resistance today at {str(resistance)} for {past_time_interval} time interval. Price is {str(price)}."

    else:
        break_through = " "
        words = "No resistance broken"
        past_time_interval = " "
        next_time_interval = " "
        resistance = " "
        next_resistance = " "
        price = " "

    all_resistances.clear()
    return words, break_through, past_time_interval, next_time_interval, resistance, next_resistance

New Code:
def create_resistance_report(ticker,current_price,previous_close):
    get_resistance = get_stock_resistance_for_any_interval(ticker,current_price,previous_close)

    if get_resistance is not None:
        next_highest_resistance, interval = get_next_high_for_any_interval(current_price)
        resistance = float(get_resistance['Resistance']).__round__(2)
        break_through = get_resistance['break_through']
        past_time_interval = get_resistance['time_interval']
        next_time_interval = interval
        price = get_resistance['price']
        next_resistance = float(next_highest_resistance).__round__(2)
        words = f" crossed resistance today at {str(resistance)} for {past_time_interval} time interval. Price is {str(price)}."

    else:
        break_through = " "
        words = "No resistance broken"
        past_time_interval = " "
        next_time_interval = " "
        resistance = " "
        next_resistance = " "
        price = " "

    all_resistances.clear()
    return words, break_through, past_time_interval, next_time_interval, resistance, next_resistance, price



Changes
It appears that you are generically passing an `Exception` object without performing any other operation on it. This may hide error conditions that can otherwise be quickly detected and addressed. We recommend that you catch a more specific exception. If the code must broadly catch all exceptions, consider logging the stack trace using the [logging.exception()](https://docs.python.org/3/library/logging.html#logging.exception) API. For example,

```
try:
    x = 1 / 0
except ZeroDivisionError as e:
    logging.exception('ZeroDivisionError: %s', e)

```
Old Code:
def nyse(stock, time_interval):
    try:
        stock_exchange = 'NYSE'
        handler = TA_Handler(
            symbol= stock,
            exchange=stock_exchange,
            screener="america",
            interval=time_interval,
            timeout=None
        )

        # analysis = 
        summary = handler.get_analysis().summary
        overall_recommendation = summary['RECOMMENDATION']
        print(time_interval,"=",overall_recommendation)
        return overall_recommendation
    except:
        Exception
    


New Code:
def nyse(stock, time_interval):
    try:
        stock_exchange = 'NYSE'
        handler = TA_Handler(
            symbol= stock,
            exchange=stock_exchange,
            screener="america",
            interval=time_interval,
            timeout=None
        )

        # analysis = 
        summary = handler.get_analysis().summary
        overall_recommendation = summary['RECOMMENDATION']
        print(time_interval,"=",overall_recommendation)
        return overall_recommendation
    except:
        logging.exception('ZeroDivisionError: %s', e)
    



Changes
It appears your code contains a hardcoded API Gateway API Key. Hardcoded secrets or credentials can allow attackers to bypass authentication methods and perform malicious actions. We recommend revoking access to resources using this credential and storing future credentials in a management service such as [AWS Secrets Manager](https://aws.amazon.com/secrets-manager/).

[Learn more about the use of hardcoded credentials](https://cwe.mitre.org/data/definitions/798.html)
Old Code:
def look_up_exchange(tick):
    url = f'https://financialmodelingprep.com/api/v3/search?query={tick}&limit=10&apikey=e49e22b0865cfeea71aa0771ddf965a1'

    r = requests.get(url)
    return r.json()[0].get('exchangeShortName')

New Code:
def look_up_exchange(tick):
    url = f'https://financialmodelingprep.com/api/v3/search?query={tick}&limit=10&apikey=API_KEY'

    r = requests.get(url)
    return r.json()[0].get('exchangeShortName')



Changes
To create a `list`, try to use `list` comprehension instead of a loop. List comprehension is the preferred way to make a list using Python, and it's simpler and easier to understand than using a loop.

[Learn more](https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions)
Old Code:
def get_stock_resistance_for_any_interval(ticker,current_price,previous_close):
    resistance_levels = ['15','30','60','D','W','M']

    resistance_level_bank = [
        check_if_resistance_broken(
            ticker, level, current_price, previous_close
        )
        for level in resistance_levels
    ]

    return next(
        (
            resistance_level
            for resistance_level in resistance_level_bank
            if resistance_level['break_through'] == 'True'
        ),
        None,
    )

New Code:
def get_stock_resistance_for_any_interval(ticker,current_price,previous_close):
    resistance_level_bank = [
        check_if_resistance_broken(
            ticker, level, current_price, previous_close
        )
        for level in ['15','30','60','D','W','M']
    ]

    return next(
        (
            resistance_level
            for resistance_level in resistance_level_bank
            if resistance_level['break_through'] == 'True'
        ),
        None,
    )



Changes
To create a `list`, try to use `list` comprehension instead of a loop. List comprehension is the preferred way to make a list using Python, and it's simpler and easier to understand than using a loop.

[Learn more](https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions)
Old Code:
def get_stock_resistance_for_any_interval(ticker,current_price,previous_close):
    resistance_levels = ['15','30','60','D','W','M']

    resistance_level_bank = [
        check_if_resistance_broken(
            ticker, level, current_price, previous_close
        )
        for level in resistance_levels
    ]

    return next(
        (
            resistance_level
            for resistance_level in resistance_level_bank
            if resistance_level['break_through'] == 'True'
        ),
        None,
    )

New Code:
def get_stock_resistance_for_any_interval(ticker,current_price,previous_close):
    resistance_level_bank = [
        check_if_resistance_broken(
            ticker, level, current_price, previous_close
        )
        for level in ['15','30','60','D','W','M']
    ]

    return next(
        (
            resistance_level
            for resistance_level in resistance_level_bank
            if resistance_level['break_through'] == 'True'
        ),
        None,
    )



Changes
To create a `list`, try to use `list` comprehension instead of a loop. List comprehension is the preferred way to make a list using Python, and it's simpler and easier to understand than using a loop.

[Learn more](https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions)
Old Code:
def get_stock_resistance_for_any_interval(ticker,current_price,previous_close):
    resistance_level_bank = [
        check_if_resistance_broken(
            ticker, level, current_price, previous_close
        )
        for level in ['15','30','60','D','W','M']
    ]

    return next(
        (
            resistance_level
            for resistance_level in resistance_level_bank
            if resistance_level['break_through'] == 'True'
        ),
        None,
    )


New Code:
def get_stock_resistance_for_any_interval(ticker,current_price,previous_close):
    resistance_level_bank = [  # To create a `list`, try to use `list` comprehension instead of a loop. List comprehension is the preferred way to make a list using Python, and it's simpler and easier to understand than using a loop.
        check_if_resistance_broken(
            ticker, level, current_price, previous_close
        )
        for level in ['15','30','60','D','W','M']
    ]

    return next(
        (
            resistance_level
            for resistance_level in resistance_level_bank
            if resistance_level['break_through'] == 'True'
        ),
        None,
    )



Changes
To create a `list`, try to use `list` comprehension instead of a loop. List comprehension is the preferred way to make a list using Python, and it's simpler and easier to understand than using a loop.

[Learn more](https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions)
Old Code:
def get_stock_resistance_for_any_interval(ticker,current_price,previous_close):
    resistance_level_bank = [
        check_if_resistance_broken(
            ticker, level, current_price, previous_close
        )
        for level in ['15','30','60','D','W','M']
    ]

    return next(
        (
            resistance_level
            for resistance_level in resistance_level_bank
            if resistance_level['break_through'] == 'True'
        ),
        None,
    )


New Code:
def get_stock_resistance_for_any_interval(ticker,current_price,previous_close):
    resistance_level_bank = [  # To create a `list`, try to use `list` comprehension instead of a loop. List comprehension is the preferred way to make a list using Python, and it's simpler and easier to understand than using a loop.
        check_if_resistance_broken(
            ticker, level, current_price, previous_close
        )
        for level in ['15','30','60','D','W','M']
    ]

    return next(
        (
            resistance_level
            for resistance_level in resistance_level_bank
            if resistance_level['break_through'] == 'True'
        ),
        None,
    )



Changes
To create a `list`, try to use `list` comprehension instead of a loop. List comprehension is the preferred way to make a list using Python, and it's simpler and easier to understand than using a loop.

[Learn more](https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions)
Old Code:
def get_stock_resistance_for_any_interval(ticker,current_price,previous_close):
    resistance_level_bank = [
        check_if_resistance_broken(
            ticker, level, current_price, previous_close
        )
        for level in ['15','30','60','D','W','M']
    ]

    return next(
        (
            resistance_level
            for resistance_level in resistance_level_bank
            if resistance_level['break_through'] == 'True'
        ),
        None,
    )


New Code:
def get_stock_resistance_for_any_interval(ticker,current_price,previous_close):
    resistance_level_bank = [  # To create a `list`, try to use `list` comprehension instead of a loop. List comprehension is the preferred way to make a list using Python, and it's simpler and easier to understand than using a loop.
        check_if_resistance_broken(
            ticker, level, current_price, previous_close
        )
        for level in ['15','30','60','D','W','M']
    ]

    return next(
        (
            resistance_level
            for resistance_level in resistance_level_bank
            if resistance_level['break_through'] == 'True'
        ),
        None,
    )



Changes
To create a `list`, try to use `list` comprehension instead of a loop. List comprehension is the preferred way to make a list using Python, and it's simpler and easier to understand than using a loop.

[Learn more](https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions)
Old Code:
def get_stock_resistance_for_any_interval(ticker,current_price,previous_close):
    resistance_level_bank = [
        check_if_resistance_broken(
            ticker, level, current_price, previous_close
        )
        for level in ['15','30','60','D','W','M']
    ]

    return next(
        (
            resistance_level
            for resistance_level in resistance_level_bank
            if resistance_level['break_through'] == 'True'
        ),
        None,
    )


New Code:
def get_stock_resistance_for_any_interval(ticker,current_price,previous_close):
    resistance_level_bank = [  # To create a `list`, try to use `list` comprehension instead of a loop. List comprehension is the preferred way to make a list using Python, and it's simpler and easier to understand than using a loop.
        check_if_resistance_broken(
            ticker, level, current_price, previous_close
        )
        for level in ['15','30','60','D','W','M']
    ]

    return next(
        (
            resistance_level
            for resistance_level in resistance_level_bank
            if resistance_level['break_through'] == 'True'
        ),
        None,
    )



Changes
To create a `list`, try to use `list` comprehension instead of a loop. List comprehension is the preferred way to make a list using Python, and it's simpler and easier to understand than using a loop.

[Learn more](https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions)
Old Code:
def get_stock_resistance_for_any_interval(ticker,current_price,previous_close):
    resistance_level_bank = [
        check_if_resistance_broken(
            ticker, level, current_price, previous_close
        )
        for level in ['15','30','60','D','W','M']
    ]

    return next(
        (
            resistance_level
            for resistance_level in resistance_level_bank
            if resistance_level['break_through'] == 'True'
        ),
        None,
    )


New Code:
def get_stock_resistance_for_any_interval(ticker,current_price,previous_close):
    resistance_level_bank = [  # To create a `list`, try to use `list` comprehension instead of a loop. List comprehension is the preferred way to make a list using Python, and it's simpler and easier to understand than using a loop.
        check_if_resistance_broken(
            ticker, level, current_price, previous_close
        )
        for level in ['15','30','60','D','W','M']
    ]

    return next(
        (
            resistance_level
            for resistance_level in resistance_level_bank
            if resistance_level['break_through'] == 'True'
        ),
        None,
    )



Changes
To create a `list`, try to use `list` comprehension instead of a loop. List comprehension is the preferred way to make a list using Python, and it's simpler and easier to understand than using a loop.

[Learn more](https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions)
Old Code:
def get_stock_resistance_for_any_interval(ticker,current_price,previous_close):
    resistance_level_bank = [
        check_if_resistance_broken(
            ticker, level, current_price, previous_close
        )
        for level in ['15','30','60','D','W','M']
    ]

    return next(
        (
            resistance_level
            for resistance_level in resistance_level_bank
            if resistance_level['break_through'] == 'True'
        ),
        None,
    )


New Code:
def get_stock_resistance_for_any_interval(ticker,current_price,previous_close):
    resistance_level_bank = [  # To create a `list`, try to use `list` comprehension instead of a loop. List comprehension is the preferred way to make a list using Python, and it's simpler and easier to understand than using a loop.
        check_if_resistance_broken(
            ticker, level, current_price, previous_close
        )
        for level in ['15','30','60','D','W','M']
    ]

    return next(
        (
            resistance_level
            for resistance_level in resistance_level_bank
            if resistance_level['break_through'] == 'True'
        ),
        None,
    )



Changes
To create a `list`, try to use `list` comprehension instead of a loop. List comprehension is the preferred way to make a list using Python, and it's simpler and easier to understand than using a loop.

[Learn more](https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions)
Old Code:
def get_stock_resistance_for_any_interval(ticker,current_price,previous_close):
    resistance_level_bank = [
        check_if_resistance_broken(
            ticker, level, current_price, previous_close
        )
        for level in ['15','30','60','D','W','M']
    ]

    return next(
        (
            resistance_level
            for resistance_level in resistance_level_bank
            if resistance_level['break_through'] == 'True'
        ),
        None,
    )


New Code:
def get_stock_resistance_for_any_interval(ticker,current_price,previous_close):
    resistance_level_bank = [  # To create a `list`, try to use `list` comprehension instead of a loop. List comprehension is the preferred way to make a list using Python, and it's simpler and easier to understand than using a loop.
        check_if_resistance_broken(
            ticker, level, current_price, previous_close
        )
        for level in ['15','30','60','D','W','M']
    ]

    return next(
        (
            resistance_level
            for resistance_level in resistance_level_bank
            if resistance_level['break_through'] == 'True'
        ),
        None,
    )



Changes
To create a `list`, try to use `list` comprehension instead of a loop. List comprehension is the preferred way to make a list using Python, and it's simpler and easier to understand than using a loop.

[Learn more](https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions)
Old Code:
def get_stock_resistance_for_any_interval(ticker,current_price,previous_close):
    resistance_level_bank = [  # To create a `list`, try to use `list` comprehension instead of a loop. List comprehension is the preferred way to make a list using Python, and it's simpler and easier to understand than using a loop.
        check_if_resistance_broken(
            ticker, level, current_price, previous_close
        )
        for level in ['15','30','60','D','W','M']
    ]

    return next(
        (
            resistance_level
            for resistance_level in resistance_level_bank
            if resistance_level['break_through'] == 'True'
        ),
        None,
    )



New Code:
def get_stock_resistance_for_any_interval(ticker,current_price,previous_close):
    resistance_level_bank = [  # To create a `list`, try to use `list` comprehension instead of a loop. List comprehension is the preferred way to make a list using Python, and it's simpler and easier to understand than using a loop. [Learn more](https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions)
        check_if_resistance_broken(
            ticker, level, current_price, previous_close
        )
        for level in ['15','30','60','D','W','M']
    ]

    return next(
        (
            resistance_level
            for resistance_level in resistance_level_bank
            if resistance_level['break_through'] == 'True'
        ),
        None,
    )




Changes
To check if a container or sequence (string, list, tuple) is empty, use `if not val`. Do not compare its length using `if len(val) == 0` or `if len(val) > 0`

 [Learn more](https://www.python.org/dev/peps/pep-0008/#programming-recommendations#:~:text=if%20not%20seq)
Old Code:
def get_resistance_levels(ticker, interval):
    url = f'https://finnhub.io/api/v1/scan/support-resistance?symbol={str(ticker)}&resolution={str(interval)}&token={finnhub_api_key_2}'

    r = requests.get(url)
    resistance_levels = r.json()
    resistance_levels = resistance_levels['levels']

    if len(resistance_levels) != 0:
        for x in resistance_levels:
            json = {"interval": interval,"resistance":x}
            all_resistances.append(json)
    return resistance_levels
New Code:
def get_resistance_levels(ticker, interval):
    url = f'https://finnhub.io/api/v1/scan/support-resistance?symbol={str(ticker)}&resolution={str(interval)}&token={finnhub_api_key_2}'

    r = requests.get(url)
    resistance_levels = r.json()
    resistance_levels = resistance_levels['levels']

    if resistance_levels:
        for x in resistance_levels:
            json = {"interval": interval,"resistance":x}
            all_resistances.append(json)
    return resistance_levels



Changes
To create a `list`, try to use `list` comprehension instead of a loop. List comprehension is the preferred way to make a list using Python, and it's simpler and easier to understand than using a loop.

[Learn more](https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions)
Old Code:
def get_stock_resistance_for_any_interval(ticker,current_price,previous_close):
    resistance_level_bank = [
        check_if_resistance_broken(
            ticker, level, current_price, previous_close
        )
        for level in ['15','30','60','D','W','M']
    ]

    return next(
        (
            resistance_level
            for resistance_level in resistance_level_bank
            if resistance_level['break_through'] == 'True'
        ),
        None,
    )


New Code:
def get_stock_resistance_for_any_interval(ticker,current_price,previous_close):
    resistance_level_bank = [  # To create a `list`, try to use `list` comprehension instead of a loop. List comprehension is the preferred way to make a list using Python, and it's simpler and easier to understand than using a loop.
        check_if_resistance_broken(
            ticker, level, current_price, previous_close
        )
        for level in ['15','30','60','D','W','M']
    ]

    return next(
        (
            resistance_level
            for resistance_level in resistance_level_bank
            if resistance_level['break_through'] == 'True'
        ),
        None,
    )



Changes
To check if a container or sequence (string, list, tuple) is empty, use `if not val`. Do not compare its length using `if len(val) == 0` or `if len(val) > 0`

 [Learn more](https://www.python.org/dev/peps/pep-0008/#programming-recommendations#:~:text=if%20not%20seq)
Old Code:
def get_resistance_levels(ticker, interval):
    url = f'https://finnhub.io/api/v1/scan/support-resistance?symbol={str(ticker)}&resolution={str(interval)}&token={finnhub_api_key_2}'

    r = requests.get(url)
    resistance_levels = r.json()
    resistance_levels = resistance_levels['levels']

    if len(resistance_levels) != 0:
        for x in resistance_levels:
            json = {"interval": interval,"resistance":x}
            all_resistances.append(json)
    return resistance_levels
New Code:
def get_resistance_levels(ticker, interval):
    url = f'https://finnhub.io/api/v1/scan/support-resistance?symbol={str(ticker)}&resolution={str(interval)}&token={finnhub_api_key_2}'

    r = requests.get(url)
    resistance_levels = r.json()
    resistance_levels = resistance_levels['levels']

    if resistance_levels:
        for x in resistance_levels:
            json = {"interval": interval,"resistance":x}
            all_resistances.append(json)
    return resistance_levels



Changes
It appears you are unpacking more than three variables while using a function that returns more than one variable. Using a large number of return values is prone to errors. We recommend that you return a small class or `namedtuple` instance instead.

[Learn more](https://docs.python.org/3/library/typing.html#typing.NamedTuple)

Similar issue at line number 146.
Old Code:
def create_resistance_report(ticker,current_price,previous_close):
    get_resistance = get_stock_resistance_for_any_interval(ticker,current_price,previous_close)

    if get_resistance is not None:
        next_highest_resistance, interval = get_next_high_for_any_interval(current_price)
        resistance = float(get_resistance['Resistance']).__round__(2)
        break_through = get_resistance['break_through']
        past_time_interval = get_resistance['time_interval']
        next_time_interval = interval
        price = get_resistance['price']
        next_resistance = float(next_highest_resistance).__round__(2)
        words = f" crossed resistance today at {str(resistance)} for {past_time_interval} time interval. Price is {str(price)}."

    else:
        break_through = " "
        words = "No resistance broken"
        past_time_interval = " "
        next_time_interval = " "
        resistance = " "
        next_resistance = " "
        price = " "

    all_resistances.clear()
    return words, break_through, past_time_interval, next_time_interval, resistance, next_resistance

New Code:
def create_resistance_report(ticker,current_price,previous_close):
    get_resistance = get_stock_resistance_for_any_interval(ticker,current_price,previous_close)

    if get_resistance is not None:
        next_highest_resistance, interval = get_next_high_for_any_interval(current_price)
        resistance = float(get_resistance['Resistance']).__round__(2)
        break_through = get_resistance['break_through']
        past_time_interval = get_resistance['time_interval']
        next_time_interval = interval
        price = get_resistance['price']
        next_resistance = float(next_highest_resistance).__round__(2)
        words = f" crossed resistance today at {str(resistance)} for {past_time_interval} time interval. Price is {str(price)}."

    else:
        break_through = " "
        words = "No resistance broken"
        past_time_interval = " "
        next_time_interval = " "
        resistance = " "
        next_resistance = " "
        price = " "

    all_resistances.clear()
    return words, break_through, past_time_interval, next_time_interval, resistance, next_resistance, price



Changes
It appears that you are generically passing an `Exception` object without performing any other operation on it. This may hide error conditions that can otherwise be quickly detected and addressed. We recommend that you catch a more specific exception. If the code must broadly catch all exceptions, consider logging the stack trace using the [logging.exception()](https://docs.python.org/3/library/logging.html#logging.exception) API. For example,

```
try:
    x = 1 / 0
except ZeroDivisionError as e:
    logging.exception('ZeroDivisionError: %s', e)

```
Old Code:
def nyse(stock, time_interval):
    try:
        stock_exchange = 'NYSE'
        handler = TA_Handler(
            symbol= stock,
            exchange=stock_exchange,
            screener="america",
            interval=time_interval,
            timeout=None
        )

        # analysis = 
        summary = handler.get_analysis().summary
        overall_recommendation = summary['RECOMMENDATION']
        print(time_interval,"=",overall_recommendation)
        return overall_recommendation
    except:
        Exception
    


New Code:
def nyse(stock, time_interval):
    try:
        stock_exchange = 'NYSE'
        handler = TA_Handler(
            symbol= stock,
            exchange=stock_exchange,
            screener="america",
            interval=time_interval,
            timeout=None
        )

        # analysis = 
        summary = handler.get_analysis().summary
        overall_recommendation = summary['RECOMMENDATION']
        print(time_interval,"=",overall_recommendation)
        return overall_recommendation
    except:
        logging.exception('ZeroDivisionError: %s', e)
    



Changes
It appears your code contains a hardcoded API Gateway API Key. Hardcoded secrets or credentials can allow attackers to bypass authentication methods and perform malicious actions. We recommend revoking access to resources using this credential and storing future credentials in a management service such as [AWS Secrets Manager](https://aws.amazon.com/secrets-manager/).

[Learn more about the use of hardcoded credentials](https://cwe.mitre.org/data/definitions/798.html)
Old Code:
def look_up_exchange(tick):
    url = f'https://financialmodelingprep.com/api/v3/search?query={tick}&limit=10&apikey=e49e22b0865cfeea71aa0771ddf965a1'

    r = requests.get(url)
    return r.json()[0].get('exchangeShortName')

New Code:
def look_up_exchange(tick):
    url = f'https://financialmodelingprep.com/api/v3/search?query={tick}&limit=10&apikey=API_KEY'

    r = requests.get(url)
    return r.json()[0].get('exchangeShortName')



Changes
**Problem**
This line of code might contain a resource leak. Resource leaks can cause your system to slow down or crash.

**Fix**
Consider closing the following resource: *session*. The resource is allocated by call *sessions.Session*. Currently, there are execution paths that do not contain closure statements, for example, when *Session.get()* throws an exception. To prevent this resource leak, close *session* in a try-finally block or declare it using a `with` statement.

**More info**
[View details about the `with` statement in the Python developer's guide](https://www.python.org/dev/peps/pep-0343/) (external link).
Old Code:
def scrape_highest_iv_stocks():
    session = requests.Session()
    main_page_url = 'https://www.barchart.com/options/highest-implied-volatility/highest?sector=stock'
    url = f"https://www.barchart.com/proxies/core-api/v1/options/get?fields=symbol,baseSymbol,baseLastPrice,baseSymbolType,symbolType,strikePrice,expirationDate,daysToExpiration,bidPrice,midpoint,askPrice,lastPrice,volume,openInterest,volumeOpenInterestRatio,volatility,tradeTime,symbolCode,hasOptions&orderBy=volatility&baseSymbolTypes=stock&between(lastPrice,.10,)=&between(daysToExpiration,15,)=&between(tradeTime,{week_ago_date},{today_date})=&orderDir=desc&between(volatility,60,)=&limit=200&between(volume,500,)=&between(openInterest,100,)=&in(exchange,(AMEX,NASDAQ,NYSE))=&meta=field.shortName,field.type,field.description&hasOptions=true&raw=1"

    payload={}
    headers = {
    'sec-ch-ua': '"Chromium";v="88", "Google Chrome";v="88", ";Not A Brand";v="99"',
    'Accept': 'application/json',
    'DNT': '1',
    'sec-ch-ua-mobile': '?0',
    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.104 Safari/537.36',
    'Sec-Fetch-Site': 'same-origin',
    'Sec-Fetch-Mode': 'cors',
    'Sec-Fetch-Dest': 'empty'
    }

    r = session.get(main_page_url,headers=headers)
    headers['X-XSRF-TOKEN'] = unquote(unquote(session.cookies.get_dict()['XSRF-TOKEN']))
    response = session.request("GET", url, headers=headers, data=payload)
    return [stock_ticker['baseSymbol'] for stock_ticker in response.json()['data'] if stock_ticker not in highest_iv_stocks]





New Code:
def scrape_highest_iv_stocks():
    with requests.Session() as session:
    main_page_url = 'https://www.barchart.com/options/highest-implied-volatility/highest?sector=stock'
    url = f"https://www.barchart.com/proxies/core-api/v1/options/get?fields=symbol,baseSymbol,baseLastPrice,baseSymbolType,symbolType,strikePrice,expirationDate,daysToExpiration,bidPrice,midpoint,askPrice,lastPrice,volume,openInterest,volumeOpenInterestRatio,volatility,tradeTime,symbolCode,hasOptions&orderBy=volatility&baseSymbolTypes=stock&between(lastPrice,.10,)=&between(daysToExpiration,15,)=&between(tradeTime,{week_ago_date},{today_date})=&orderDir=desc&between(volatility,60,)=&limit=200&between(volume,500,)=&between(openInterest,100,)=&in(exchange,(AMEX,NASDAQ,NYSE))=&meta=field.shortName,field.type,field.description&hasOptions=true&raw=1"

    payload={}
    headers = {
    'sec-ch-ua': '"Chromium";v="88", "Google Chrome";v="88", ";Not A Brand";v="99"',
    'Accept': 'application/json',
    'DNT': '1',
    'sec-ch-ua-mobile': '?0',
    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.104 Safari/537.36',
    'Sec-Fetch-Site': 'same-origin',
    'Sec-Fetch-Mode': 'cors',
    'Sec-Fetch-Dest': 'empty'
    }

    r = session.get(main_page_url,headers=headers)
    headers['X-XSRF-TOKEN'] = unquote(unquote(session.cookies.get_dict()['XSRF-TOKEN']))
    response = session.request("GET", url, headers=headers, data=payload)
    return [stock_ticker['baseSymbol'] for stock_ticker in response.json()['data'] if stock_ticker not in highest_iv_stocks]






Changes
The naive datetime objects are treated by many datetime methods as local times, it is preferred to use aware datetimes to represent times in UTC. The recommended way to create an aware datetime object representing a specific timestamp in UTC is by passing `tzinfo` as an argument to the method.

[Learn more](https://docs.python.org/3/library/datetime.html#aware-and-naive-objects)
Old Code:
def scrape_highest_iv_stocks():
    with requests.Session() as session:
    main_page_url = 'https://www.barchart.com/options/highest-implied-volatility/highest?sector=stock'
    url = f"https://www.barchart.com/proxies/core-api/v1/options/get?fields=symbol,baseSymbol,baseLastPrice,baseSymbolType,symbolType,strikePrice,expirationDate,daysToExpiration,bidPrice,midpoint,askPrice,lastPrice,volume,openInterest,volumeOpenInterestRatio,volatility,tradeTime,symbolCode,hasOptions&orderBy=volatility&baseSymbolTypes=stock&between(lastPrice,.10,)=&between(daysToExpiration,15,)=&between(tradeTime,{week_ago_date},{today_date})=&orderDir=desc&between(volatility,60,)=&limit=200&between(volume,500,)=&between(openInterest,100,)=&in(exchange,(AMEX,NASDAQ,NYSE))=&meta=field.shortName,field.type,field.description&hasOptions=true&raw=1"

    payload={}
    headers = {
    'sec-ch-ua': '"Chromium";v="88", "Google Chrome";v="88", ";Not A Brand";v="99"',
    'Accept': 'application/json',
    'DNT': '1',
    'sec-ch-ua-mobile': '?0',
    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.104 Safari/537.36',
    'Sec-Fetch-Site': 'same-origin',
    'Sec-Fetch-Mode': 'cors',
    'Sec-Fetch-Dest': 'empty'
    }

    r = session.get(main_page_url,headers=headers)
    headers['X-XSRF-TOKEN'] = unquote(unquote(session.cookies.get_dict()['XSRF-TOKEN']))
    response = session.request("GET", url, headers=headers, data=payload)
    return [stock_ticker['baseSymbol'] for stock_ticker in response.json()['data'] if stock_ticker not in highest_iv_stocks]






New Code:
def scrape_highest_iv_stocks():
    with requests.Session() as session:
    main_page_url = 'https://www.barchart.com/options/highest-implied-volatility/highest?sector=stock'
    url = f"https://www.barchart.com/proxies/core-api/v1/options/get?fields=symbol,baseSymbol,baseLastPrice,baseSymbolType,symbolType,strikePrice,expirationDate,daysToExpiration,bidPrice,midpoint,askPrice,lastPrice,volume,openInterest,volumeOpenInterestRatio,volatility,tradeTime,symbolCode,hasOptions&orderBy=volatility&baseSymbolTypes=stock&between(lastPrice,.10,)=&between(daysToExpiration,15,)=&between(tradeTime,{week_ago_date},{today_date})=&orderDir=desc&between(volatility,60,)=&limit=200&between(volume,500,)=&between(openInterest,100,)=&in(exchange,(AMEX,NASDAQ,NYSE))=&meta=field.shortName,field.type,field.description&hasOptions=true&raw=1"

    payload={}
    headers = {
    'sec-ch-ua': '"Chromium";v="88", "Google Chrome";v="88", ";Not A Brand";v="99"',
    'Accept': 'application/json',
    'DNT': '1',
    'sec-ch-ua-mobile': '?0',
    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.104 Safari/537.36',
    'Sec-Fetch-Site': 'same-origin',
    'Sec-Fetch-Mode': 'cors',
    'Sec-Fetch-Dest': 'empty'
    }

    r = session.get(main_page_url,headers=headers)
    headers['X-XSRF-TOKEN'] = unquote(unquote(session.cookies.get_dict()['XSRF-TOKEN']))
    response = session.request("GET", url, headers=headers, data=payload)
    highest_iv_stocks = [stock_ticker['baseSymbol'] for stock_ticker in response.json()['data']]
    return [stock_ticker['baseSymbol'] for stock_ticker in response.json()['data'] if stock_ticker not in highest_iv_stocks]







Changes
To create a `list`, try to use `list` comprehension instead of a loop. List comprehension is the preferred way to make a list using Python, and it's simpler and easier to understand than using a loop.

[Learn more](https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions)
Old Code:
def get_stock_resistance_for_any_interval(ticker,current_price,previous_close):
    resistance_level_bank = [  # To create a `list`, try to use `list` comprehension instead of a loop. List comprehension is the preferred way to make a list using Python, and it's simpler and easier to understand than using a loop.
        check_if_resistance_broken(
            ticker, level, current_price, previous_close
        )
        for level in ['15','30','60','D','W','M']
    ]

    return next(
        (
            resistance_level
            for resistance_level in resistance_level_bank
            if resistance_level['break_through'] == 'True'
        ),
        None,
    )



New Code:
def get_stock_resistance_for_any_interval(ticker,current_price,previous_close):
    resistance_level_bank = [  # To create a `list`, try to use `list` comprehension instead of a loop. List comprehension is the preferred way to make a list using Python, and it's simpler and easier to understand than using a loop. [Learn more](https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions)
        check_if_resistance_broken(
            ticker, level, current_price, previous_close
        )
        for level in ['15','30','60','D','W','M']
    ]

    return next(
        (
            resistance_level
            for resistance_level in resistance_level_bank
            if resistance_level['break_through'] == 'True'
        ),
        None,
    )




Changes
It appears you are unpacking more than three variables while using a function that returns more than one variable. Using a large number of return values is prone to errors. We recommend that you return a small class or `namedtuple` instance instead.

[Learn more](https://docs.python.org/3/library/typing.html#typing.NamedTuple)
Old Code:
def calculate_stock_percentage_gain_today(current_price, previous_close): 
    previous_close = float(previous_close)
    day_gain = ((current_price/previous_close) - 1) * 100
    day_gain = day_gain.__round__(2)
    return day_gain

New Code:
def calculate_stock_percentage_gain_today(current_price, previous_close):
    previous_close = float(previous_close)
    day_gain = ((current_price/previous_close) - 1) * 100
    day_gain = day_gain.__round__(2)
    return day_gain



Changes
It appears you are unpacking more than three variables while using a function that returns more than one variable. Using a large number of return values is prone to errors. We recommend that you return a small class or `namedtuple` instance instead.

[Learn more](https://docs.python.org/3/library/typing.html#typing.NamedTuple)
Old Code:
def calculate_stock_percentage_gain_today(current_price, previous_close):
    previous_close = float(previous_close)
    day_gain = ((current_price/previous_close) - 1) * 100
    day_gain = day_gain.__round__(2)
    return day_gain


New Code:
def calculate_stock_percentage_gain_today(current_price, previous_close, day_gain):
    previous_close = float(previous_close)
    day_gain = ((current_price/previous_close) - 1) * 100
    day_gain = day_gain.__round__(2)
    return day_gain



Changes
Using `Exception` and `BaseException` can make your code prone to errors and difficult to maintain. Instead, we recommend using one of the [Built-in Exceptions](https://docs.python.org/3/library/exceptions.html) or creating a custom exception class that is derived from `Exception` or one of its subclasses.


Old Code:
def get_function_code(function_name, file_name):
    """
    Gets the code of a function in a file.
    :param function_name: The name of the function to get the code of.
    :param file_name: The name of the file to search in.
    :return: The code of the function.
    """
    with open(file_name, 'r') as file:
        code = file.read()
    # first find the function definition:
    function_def = re.search(r'\n\s*def\s+' + function_name + r'\(', code, re.MULTILINE)
    if not function_def:
        raise Exception("Could not find function definition for " + function_name)
    function_def = function_def.group()
    # now find the beginning and end of the function code:
    function_begin = code.find(function_def)
    function_end = function_begin + len(function_def)
    # to find the end, we need to find the next function definition (or the end of the file):
    next_function_def = re.search(r'\n\s*def\s+[a-zA-Z0-9_]+\(', code[function_end:], re.MULTILINE)
    if next_function_def:
        indentation_level = function_def.count('\t') + 1
        # now get the indentation level, we don't want any lines that have a lesser indentation
        while code[function_end:].startswith('\t' * indentation_level):
            function_end += 1
        function_end += next_function_def.start() - 1
    else:
        function_end = len(code)
    # now get the function code:
    return code[function_begin:function_end]


New Code:
def get_function_code(function_name, file_name):
    """
    Gets the code of a function in a file.
    :param function_name: The name of the function to get the code of.
    :param file_name: The name of the file to search in.
    :return: The code of the function.
    """
    with open(file_name, 'r') as file:
        code = file.read()
    # first find the function definition:
    function_def = re.search(r'\n\s*def\s+' + function_name + r'\(', code, re.MULTILINE)
    if not function_def:
        raise ValueError("Could not find function definition for " + function_name)
    function_def = function_def.group()
    # now find the beginning and end of the function code:
    function_begin = code.find(function_def)
    function_end = function_begin + len(function_def)
    # to find the end, we need to find the next function definition (or the end of the file):
    next_function_def = re.search(r'\n\s*def\s+[a-zA-Z0-9_]+\(', code[function_end:], re.MULTILINE)
    if next_function_def:
        indentation_level = function_def.count('\t') + 1
        # now get the indentation level, we don't want any lines that have a lesser indentation
        while code[function_end:].startswith('\t' * indentation_level):
            function_end += 1
        function_end += next_function_def.start() - 1
    else:
        function_end = len(code)
    # now get the function code:
    return code[function_begin:function_end]



Changes
Using `Exception` and `BaseException` can make your code prone to errors and difficult to maintain. Instead, we recommend using one of the [Built-in Exceptions](https://docs.python.org/3/library/exceptions.html) or creating a custom exception class that is derived from `Exception` or one of its subclasses.


Old Code:
def get_function_code(function_name, file_name):
    """
    Gets the code of a function in a file.
    :param function_name: The name of the function to get the code of.
    :param file_name: The name of the file to search in.
    :return: The code of the function.
    """
    with open(file_name, 'r') as file:
        code = file.read()
    # first find the function definition:
    function_def = re.search(r'\n\s*def\s+' + function_name + r'\(', code, re.MULTILINE)
    if not function_def:
        raise ValueError("Could not find function definition for " + function_name)
    function_def = function_def.group()
    # now find the beginning and end of the function code:
    function_begin = code.find(function_def)
    function_end = function_begin + len(function_def)
    # to find the end, we need to find the next function definition (or the end of the file):
    next_function_def = re.search(r'\n\s*def\s+[a-zA-Z0-9_]+\(', code[function_end:], re.MULTILINE)
    if next_function_def:
        indentation_level = function_def.count('\t') + 1
        # now get the indentation level, we don't want any lines that have a lesser indentation
        while code[function_end:].startswith('\t' * indentation_level):
            function_end += 1
        function_end += next_function_def.start() - 1
    else:
        function_end = len(code)
    # now get the function code:
    return code[function_begin:function_end]



New Code:
def get_function_code(function_name, file_name):
    """
    Gets the code of a function in a file.
    :param function_name: The name of the function to get the code of.
    :param file_name: The name of the file to search in.
    :return: The code of the function.
    """
    with open(file_name, 'r') as file:
        code = file.read()
    # first find the function definition:
    function_def = re.search(r'\n\s*def\s+' + function_name + r'\(', code, re.MULTILINE)
    if not function_def:
        raise ValueError("Could not find function definition for " + function_name + " in " + file_name)
    function_def = function_def.group()
    # now find the beginning and end of the function code:
    function_begin = code.find(function_def)
    function_end = function_begin + len(function_def)
    # to find the end, we need to find the next function definition (or the end of the file):
    next_function_def = re.search(r'\n\s*def\s+[a-zA-Z0-9_]+\(', code[function_end:], re.MULTILINE)
    if next_function_def:
        indentation_level = function_def.count('\t') + 1
        # now get the indentation level, we don't want any lines that have a lesser indentation
        while code[function_end:].startswith('\t' * indentation_level):
            function_end += 1
        function_end += next_function_def.start() - 1
    else:
        function_end = len(code)
    # now get the function code:
    return code[function_begin:function_end]




Changes
Using `Exception` and `BaseException` can make your code prone to errors and difficult to maintain. Instead, we recommend using one of the [Built-in Exceptions](https://docs.python.org/3/library/exceptions.html) or creating a custom exception class that is derived from `Exception` or one of its subclasses.


Old Code:
def get_function_code(function_name, file_name):
    """
    Gets the code of a function in a file.
    :param function_name: The name of the function to get the code of.
    :param file_name: The name of the file to search in.
    :return: The code of the function.
    """
    with open(file_name, 'r') as file:
        code = file.read()

    function_def = re.search(r'\n\s*def\s+' + function_name + r'\(', code, re.MULTILINE)
    if not function_def:
        raise Exception("Could not find function definition for " + function_name)
    function_def = function_def.group()
    # Find the beginning and end of the function code:
    function_begin = code.find(function_def)
    function_end = function_begin + len(function_def)
    # to find the end, we need to find the next function definition (or the end of the file):
    next_function_def = re.search(r'\n\s*def\s+[a-zA-Z0-9_]+\(', code[function_end:], re.MULTILINE)
    if next_function_def:
        indentation_level = function_def.count('\t') + 1
        # Get the indentation level so we don't want any lines that have a lesser indentation
        while code[function_end:].startswith('\t' * indentation_level):
            function_end += 1
        function_end += next_function_def.start() - 1
    else:
        function_end = len(code)

    return code[function_begin:function_end +1 ]


New Code:
def get_function_code(function_name, file_name):
    """
    Gets the code of a function in a file.
    :param function_name: The name of the function to get the code of.
    :param file_name: The name of the file to search in.
    :return: The code of the function.
    """
    with open(file_name, 'r') as file:
        code = file.read()

    function_def = re.search(r'\n\s*def\s+' + function_name + r'\(', code, re.MULTILINE)
    if not function_def:
        raise ValueError("Could not find function definition for " + function_name)
    function_def = function_def.group()
    # Find the beginning and end of the function code:
    function_begin = code.find(function_def)
    function_end = function_begin + len(function_def)
    # to find the end, we need to find the next function definition (or the end of the file):
    next_function_def = re.search(r'\n\s*def\s+[a-zA-Z0-9_]+\(', code[function_end:], re.MULTILINE)
    if next_function_def:
        indentation_level = function_def.count('\t') + 1
        # Get the indentation level so we don't want any lines that have a lesser indentation
        while code[function_end:].startswith('\t' * indentation_level):
            function_end += 1
        function_end += next_function_def.start() - 1
    else:
        function_end = len(code)

    return code[function_begin:function_end +1 ]



Changes
Using `Exception` and `BaseException` can make your code prone to errors and difficult to maintain. Instead, we recommend using one of the [Built-in Exceptions](https://docs.python.org/3/library/exceptions.html) or creating a custom exception class that is derived from `Exception` or one of its subclasses.


Old Code:
def get_function_code(function_name, file_name):
    """
    Gets the code of a function in a file.
    :param function_name: The name of the function to get the code of.
    :param file_name: The name of the file to search in.
    :return: The code of the function.
    """
    with open(file_name, 'r') as file:
        code = file.read()

    function_def = re.search(r'\n\s*def\s+' + function_name + r'\(', code, re.MULTILINE)
    if not function_def:
        raise ValueError("Could not find function definition for " + function_name)
    function_def = function_def.group()
    # Find the beginning and end of the function code:
    function_begin = code.find(function_def)
    function_end = function_begin + len(function_def)
    # to find the end, we need to find the next function definition (or the end of the file):
    next_function_def = re.search(r'\n\s*def\s+[a-zA-Z0-9_]+\(', code[function_end:], re.MULTILINE)
    if next_function_def:
        indentation_level = function_def.count('\t') + 1
        # Get the indentation level so we don't want any lines that have a lesser indentation
        while code[function_end:].startswith('\t' * indentation_level):
            function_end += 1
        function_end += next_function_def.start() - 1
    else:
        function_end = len(code)

    return code[function_begin:function_end +1 ]



New Code:
def get_function_code(function_name, file_name):
    """
    Gets the code of a function in a file.
    :param function_name: The name of the function to get the code of.
    :param file_name: The name of the file to search in.
    :return: The code of the function.
    """
    with open(file_name, 'r') as file:
        code = file.read()

    function_def = re.search(r'\n\s*def\s+' + function_name + r'\(', code, re.MULTILINE)
    if not function_def:
        raise ValueError("Could not find function definition for " + function_name + " in " + file_name)
    function_def = function_def.group()
    # Find the beginning and end of the function code:
    function_begin = code.find(function_def)
    function_end = function_begin + len(function_def)
    # to find the end, we need to find the next function definition (or the end of the file):
    next_function_def = re.search(r'\n\s*def\s+[a-zA-Z0-9_]+\(', code[function_end:], re.MULTILINE)
    if next_function_def:
        indentation_level = function_def.count('\t') + 1
        # Get the indentation level so we don't want any lines that have a lesser indentation
        while code[function_end:].startswith('\t' * indentation_level):
            function_end += 1
        function_end += next_function_def.start() - 1
    else:
        function_end = len(code)

    return code[function_begin:function_end +1 ]




Changes
Using `Exception` and `BaseException` can make your code prone to errors and difficult to maintain. Instead, we recommend using one of the [Built-in Exceptions](https://docs.python.org/3/library/exceptions.html) or creating a custom exception class that is derived from `Exception` or one of its subclasses.


Old Code:
def get_function_code(function_name, file_name):
    """
    Gets the code of a function in a file.
    :param function_name: The name of the function to get the code of.
    :param file_name: The name of the file to search in.
    :return: The code of the function.
    """
    with open(file_name, 'r') as file:
        code = file.read()
    # first find the function definition:
    function_def = re.search(r'\n\s*def\s+' + function_name + r'\(', code, re.MULTILINE)
    if not function_def:
        raise ValueError("Could not find function definition for " + function_name + " in " + file_name)
    function_def = function_def.group()
    # now find the beginning and end of the function code:
    function_begin = code.find(function_def)
    function_end = function_begin + len(function_def)
    # to find the end, we need to find the next function definition (or the end of the file):
    next_function_def = re.search(r'\n\s*def\s+[a-zA-Z0-9_]+\(', code[function_end:], re.MULTILINE)
    if next_function_def:
        indentation_level = function_def.count('\t') + 1
        # now get the indentation level, we don't want any lines that have a lesser indentation
        while code[function_end:].startswith('\t' * indentation_level):
            function_end += 1
        function_end += next_function_def.start() - 1
    else:
        function_end = len(code)
    # now get the function code:
    return code[function_begin:function_end]





New Code:
def get_function_code(function_name, file_name):
    """
    Gets the code of a function in a file.
    :param function_name: The name of the function to get the code of.
    :param file_name: The name of the file to search in.
    :return: The code of the function.
    """
    with open(file_name, 'r') as file:
        code = file.read()
    # first find the function definition:
    function_def = re.search(r'\n\s*def\s+' + function_name + r'\(', code, re.MULTILINE)
    if not function_def:
        raise ValueError("Could not find function definition for " + function_name + " in " + file_name)  # [bad-exception]
    function_def = function_def.group()
    # now find the beginning and end of the function code:
    function_begin = code.find(function_def)
    function_end = function_begin + len(function_def)
    # to find the end, we need to find the next function definition (or the end of the file):
    next_function_def = re.search(r'\n\s*def\s+[a-zA-Z0-9_]+\(', code[function_end:], re.MULTILINE)
    if next_function_def:
        indentation_level = function_def.count('\t') + 1
        # now get the indentation level, we don't want any lines that have a lesser indentation
        while code[function_end:].startswith('\t' * indentation_level):
            function_end += 1
        function_end += next_function_def.start() - 1
    else:
        function_end = len(code)
    # now get the function code:
    return code[function_begin:function_end]






Changes
Using `Exception` and `BaseException` can make your code prone to errors and difficult to maintain. Instead, we recommend using one of the [Built-in Exceptions](https://docs.python.org/3/library/exceptions.html) or creating a custom exception class that is derived from `Exception` or one of its subclasses.


Old Code:
def get_function_code(function_name, file_name):
    """
    Gets the code of a function in a file.
    :param function_name: The name of the function to get the code of.
    :param file_name: The name of the file to search in.
    :return: The code of the function.
    """
    with open(file_name, 'r') as file:
        code = file.read()
    # first find the function definition:
    function_def = re.search(r'\n\s*def\s+' + function_name + r'\(', code, re.MULTILINE)
    if not function_def:
        raise ValueError("Could not find function definition for " + function_name + " in " + file_name)  # [bad-exception]
    function_def = function_def.group()
    # now find the beginning and end of the function code:
    function_begin = code.find(function_def)
    function_end = function_begin + len(function_def)
    # to find the end, we need to find the next function definition (or the end of the file):
    next_function_def = re.search(r'\n\s*def\s+[a-zA-Z0-9_]+\(', code[function_end:], re.MULTILINE)
    if next_function_def:
        indentation_level = function_def.count('\t') + 1
        # now get the indentation level, we don't want any lines that have a lesser indentation
        while code[function_end:].startswith('\t' * indentation_level):
            function_end += 1
        function_end += next_function_def.start() - 1
    else:
        function_end = len(code)
    # now get the function code:
    return code[function_begin:function_end]









New Code:
def get_function_code(function_name, file_name):
    """
    Gets the code of a function in a file.
    :param function_name: The name of the function to get the code of.
    :param file_name: The name of the file to search in.
    :return: The code of the function.
    """
    with open(file_name, 'r') as file:
        code = file.read()
    # first find the function definition:
    function_def = re.search(r'\n\s*def\s+' + function_name + r'\(', code, re.MULTILINE)
    if not function_def:
        raise ValueError("Could not find function definition for " + function_name + " in " + file_name)
    function_def = function_def.group()
    # now find the beginning and end of the function code:
    function_begin = code.find(function_def)
    function_end = function_begin + len(function_def)
    # to find the end, we need to find the next function definition (or the end of the file):
    next_function_def = re.search(r'\n\s*def\s+[a-zA-Z0-9_]+\(', code[function_end:], re.MULTILINE)
    if next_function_def:
        indentation_level = function_def.count('\t') + 1
        # now get the indentation level, we don't want any lines that have a lesser indentation
        while code[function_end:].startswith('\t' * indentation_level):
            function_end += 1
        function_end += next_function_def.start() - 1
    else:
        function_end = len(code)
    # now get the function code:
    return code[function_begin:function_end]










Changes
Using `Exception` and `BaseException` can make your code prone to errors and difficult to maintain. Instead, we recommend using one of the [Built-in Exceptions](https://docs.python.org/3/library/exceptions.html) or creating a custom exception class that is derived from `Exception` or one of its subclasses.


Old Code:
def get_function_code(function_name, file_name):
    """
    Gets the code of a function in a file.
    :param function_name: The name of the function to get the code of.
    :param file_name: The name of the file to search in.
    :return: The code of the function.
    """
    with open(file_name, 'r') as file:
        code = file.read()
    # first find the function definition:
    function_def = re.search(r'\n\s*def\s+' + function_name + r'\(', code, re.MULTILINE)
    if not function_def:
        raise ValueError("Could not find function definition for " + function_name + " in " + file_name)  # [bad-exception]
    function_def = function_def.group()
    # now find the beginning and end of the function code:
    function_begin = code.find(function_def)
    function_end = function_begin + len(function_def)
    # to find the end, we need to find the next function definition (or the end of the file):
    next_function_def = re.search(r'\n\s*def\s+[a-zA-Z0-9_]+\(', code[function_end:], re.MULTILINE)
    if next_function_def:
        indentation_level = function_def.count('\t') + 1
        # now get the indentation level, we don't want any lines that have a lesser indentation
        while code[function_end:].startswith('\t' * indentation_level):
            function_end += 1
        function_end += next_function_def.start() - 1
    else:
        function_end = len(code)
    # now get the function code:
    return code[function_begin:function_end]









New Code:
def get_function_code(function_name, file_name):
    """
    Gets the code of a function in a file.
    :param function_name: The name of the function to get the code of.
    :param file_name: The name of the file to search in.
    :return: The code of the function.
    """
    with open(file_name, 'r') as file:
        code = file.read()
    # first find the function definition:
    function_def = re.search(r'\n\s*def\s+' + function_name + r'\(', code, re.MULTILINE)
    if not function_def:
        raise ValueError("Could not find function definition for " + function_name + " in " + file_name)
    function_def = function_def.group()
    # now find the beginning and end of the function code:
    function_begin = code.find(function_def)
    function_end = function_begin + len(function_def)
    # to find the end, we need to find the next function definition (or the end of the file):
    next_function_def = re.search(r'\n\s*def\s+[a-zA-Z0-9_]+\(', code[function_end:], re.MULTILINE)
    if next_function_def:
        indentation_level = function_def.count('\t') + 1
        # now get the indentation level, we don't want any lines that have a lesser indentation
        while code[function_end:].startswith('\t' * indentation_level):
            function_end += 1
        function_end += next_function_def.start() - 1
    else:
        function_end = len(code)
    # now get the function code:
    return code[function_begin:function_end]










Changes
Using `Exception` and `BaseException` can make your code prone to errors and difficult to maintain. Instead, we recommend using one of the [Built-in Exceptions](https://docs.python.org/3/library/exceptions.html) or creating a custom exception class that is derived from `Exception` or one of its subclasses.


Old Code:
def get_function_code(function_name, file_name):
    """
    Gets the code of a function in a file.
    :param function_name: The name of the function to get the code of.
    :param file_name: The name of the file to search in.
    :return: The code of the function.
    """
    with open(file_name, 'r') as file:
        code = file.read()
    # first find the function definition:
    function_def = re.search(r'\n\s*def\s+' + function_name + r'\(', code, re.MULTILINE)
    if not function_def:
        raise ValueError("Could not find function definition for " + function_name + " in " + file_name)  # [bad-exception]
    function_def = function_def.group()
    # now find the beginning and end of the function code:
    function_begin = code.find(function_def)
    function_end = function_begin + len(function_def)
    # to find the end, we need to find the next function definition (or the end of the file):
    next_function_def = re.search(r'\n\s*def\s+[a-zA-Z0-9_]+\(', code[function_end:], re.MULTILINE)
    if next_function_def:
        indentation_level = function_def.count('\t') + 1
        # now get the indentation level, we don't want any lines that have a lesser indentation
        while code[function_end:].startswith('\t' * indentation_level):
            function_end += 1
        function_end += next_function_def.start() - 1
    else:
        function_end = len(code)
    # now get the function code:
    return code[function_begin:function_end]

























New Code:
def get_function_code(function_name, file_name):
    """
    Gets the code of a function in a file.
    :param function_name: The name of the function to get the code of.
    :param file_name: The name of the file to search in.
    :return: The code of the function.
    """
    with open(file_name, 'r') as file:
        code = file.read()
    # first find the function definition:
    function_def = re.search(r'\n\s*def\s+' + function_name + r'\(', code, re.MULTILINE)
    if not function_def:
        raise ValueError("Could not find function definition for " + function_name + " in " + file_name)  # [bad-exception]
    function_def = function_def.group()
    # now find the beginning and end of the function code:
    function_begin = code.find(function_def)
    function_end = function_begin + len(function_def)
    # to find the end, we need to find the next function definition (or the end of the file):
    next_function_def = re.search(r'\n\s*def\s+[a-zA-Z0-9_]+\(', code[function_end:], re.MULTILINE)
    if next_function_def:
        indentation_level = function_def.count('\t') + 1
        # now get the indentation level, we don't want any lines that have a lesser indentation
        while code[function_end:].startswith('\t' * indentation_level):
            function_end += 1
        function_end += next_function_def.start() - 1
    else:
        function_end = len(code)
    # now get the function code:
    return code[function_begin:function_end]


























Changes
Using `Exception` and `BaseException` can make your code prone to errors and difficult to maintain. Instead, we recommend using one of the [Built-in Exceptions](https://docs.python.org/3/library/exceptions.html) or creating a custom exception class that is derived from `Exception` or one of its subclasses.


Old Code:
def get_function_code(function_name, file_name):
    """
    Gets the code of a function in a file.
    :param function_name: The name of the function to get the code of.
    :param file_name: The name of the file to search in.
    :return: The code of the function.
    """
    with open(file_name, 'r') as file:
        code = file.read()

    function_def = re.search(r'\n\s*def\s+' + function_name + r'\(', code, re.MULTILINE)
    if not function_def:
        raise ValueError("Could not find function definition for " + function_name + " in " + file_name) 
    function_def = function_def.group()
    # Find the beginning and end of the function code:
    function_begin = code.find(function_def)
    function_end = function_begin + len(function_def)
    # to find the end, we need to find the next function definition (or the end of the file):
    next_function_def = re.search(r'\n\s*def\s+[a-zA-Z0-9_]+\(', code[function_end:], re.MULTILINE)
    if next_function_def:
        indentation_level = function_def.count('\t') + 1
        # Get the indentation level so we don't want any lines that have a lesser indentation
        while code[function_end:].startswith('\t' * indentation_level):
            function_end += 1
        function_end += next_function_def.start() - 1
    else:
        function_end = len(code)

    return code[function_begin:function_end +1 ]





New Code:
def get_function_code(function_name, file_name):
    """
    Gets the code of a function in a file.
    :param function_name: The name of the function to get the code of.
    :param file_name: The name of the file to search in.
    :return: The code of the function.
    """
    with open(file_name, 'r') as file:
        code = file.read()

    function_def = re.search(r'\n\s*def\s+' + function_name + r'\(', code, re.MULTILINE)
    if not function_def:
        raise ValueError("Could not find function definition for " + function_name + " in " + file_name) 
    function_def = function_def.group()
    # Find the beginning and end of the function code:
    function_begin = code.find(function_def)
    function_end = function_begin + len(function_def)
    # to find the end, we need to find the next function definition (or the end of the file):
    next_function_def = re.search(r'\n\s*def\s+[a-zA-Z0-9_]+\(', code[function_end:], re.MULTILINE)
    if next_function_def:
        indentation_level = function_def.count('\t') + 1
        # Get the indentation level so we don't want any lines that have a lesser indentation
        while code[function_end:].startswith('\t' * indentation_level):
            function_end += 1
        function_end += next_function_def.start() - 1
    else:
        function_end = len(code)

    return code[function_begin:function_end +1 ]






Changes
Using `Exception` and `BaseException` can make your code prone to errors and difficult to maintain. Instead, we recommend using one of the [Built-in Exceptions](https://docs.python.org/3/library/exceptions.html) or creating a custom exception class that is derived from `Exception` or one of its subclasses.


Old Code:
def get_function_code(function_name, file_name):
    """
    Gets the code of a function in a file.
    :param function_name: The name of the function to get the code of.
    :param file_name: The name of the file to search in.
    :return: The code of the function.
    """
    with open(file_name, 'r') as file:
        code = file.read()

    function_def = re.search(r'\n\s*def\s+' + function_name + r'\(', code, re.MULTILINE)
    if not function_def:
        raise ValueError("Could not find function definition for " + function_name + " in " + file_name)
    function_def = function_def.group()
    # Find the beginning and end of the function code:
    function_begin = code.find(function_def)
    function_end = function_begin + len(function_def)
    # to find the end, we need to find the next function definition (or the end of the file):
    next_function_def = re.search(r'\n\s*def\s+[a-zA-Z0-9_]+\(', code[function_end:], re.MULTILINE)
    if next_function_def:
        indentation_level = function_def.count('\t') + 1
        # Get the indentation level so we don't want any lines that have a lesser indentation
        while code[function_end:].startswith('\t' * indentation_level):
            function_end += 1
        function_end += next_function_def.start() - 1
    else:
        function_end = len(code)

    return code[function_begin:function_end +1 ]













New Code:
def get_function_code(function_name, file_name):
    """
    Gets the code of a function in a file.
    :param function_name: The name of the function to get the code of.
    :param file_name: The name of the file to search in.
    :return: The code of the function.
    """
    with open(file_name, 'r') as file:
        code = file.read()

    function_def = re.search(r'\n\s*def\s+' + function_name + r'\(', code, re.MULTILINE)
    if not function_def:
        raise ValueError("Could not find function definition for " + function_name + " in " + file_name)
    function_def = function_def.group()
    # Find the beginning and end of the function code:
    function_begin = code.find(function_def)
    function_end = function_begin + len(function_def)
    # to find the end, we need to find the next function definition (or the end of the file):
    next_function_def = re.search(r'\n\s*def\s+[a-zA-Z0-9_]+\(', code[function_end:], re.MULTILINE)
    if next_function_def:
        indentation_level = function_def.count('\t') + 1
        # Get the indentation level so we don't want any lines that have a lesser indentation
        while code[function_end:].startswith('\t' * indentation_level):
            function_end += 1
        function_end += next_function_def.start() - 1
    else:
        function_end = len(code)

    return code[function_begin:function_end +1 ]














Changes
**Problem:**
 This line of code lacks validation when processing input data through the following parameter: 'directory' (index: 1 | type: Unknown). The parameter is exposed to external callers, because its enclosing class and method are publicly accessible. This means that upstream validation, if it exists, can be bypassed. Other validated parameters: 'extension'. The same parameter type is validated here for example: sentient_ai_full/assistent_ai_code/whispering/audioWhisper.py:67. Malicious, malformed, or unbounded inputs can cause unexpected runtime behavior or crashes, and can slow performance.

**Fix:**
 Add checks to ensure the validity of the parameter's value, such as testing it for nullness, emptiness, or equality. Or to prevent direct calls to it, [reduce the method's visibility](https://www.python.org/dev/peps/pep-0008/#descriptive-naming-styles) using single or double underscore.

 Learn more about potential threats and guidance from the [Common Weakness Enumeration website](https://cwe.mitre.org/data/definitions/693.html) and the [OWASP Cheat Sheet series](https://cheatsheetseries.owasp.org/cheatsheets/Input_Validation_Cheat_Sheet.html).
Old Code:
def get_files_with_extension(extension, directory='.'):
    """
    Finds all the files with the given extension in the given directory.
    :param extension: The extension to find.
    :param directory: The directory to search in (defaults to the current directory).
    :return: A list of all the files with the given extension.
    """
    if not directory:
        raise ValueError('directory cannot be empty')
    # First, get all the files in the directory:
    files = glob.glob(directory + '/*')
    # Now go through all the files and add the ones with the given extension to the list:
    files_with_extension = []
    for file in files:
        if file.endswith(extension):
            files_with_extension.append(file)
    return files_with_extension

New Code:
def get_files_with_extension(extension, directory='.'):
    """
    Finds all the files with the given extension in the given directory.
    :param extension: The extension to find.
    :param directory: The directory to search in (defaults to the current directory).
    :return: A list of all the files with the given extension.
    """
    if not directory:
        raise ValueError('directory cannot be empty')
    # First, get all the files in the directory:
    files = glob.glob(directory + '/*')
    # Now go through all the files and add the ones with the given extension to the list:
    files_with_extension = []
    for file in files:
        if file.endswith(extension):
            files_with_extension.append(file)
    return files_with_extension



